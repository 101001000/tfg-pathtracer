\chapter{Introducción}
\label{chap:1}	

El renderizado 3D es una técnica por la cual se representan los datos de geometrías tridimensionales en una pantalla en dos dimensiones. Existen distintas técnicas de renderizado tridimensional, siendo el trazado de rayos la más utilizada en la industria cinematográfica gracias a su excepcional fotorrealismo del cual suelen carecer otras técnicas. Tan codiciada es esta técnica que, actualmente industrias relacionadas con la visualización 3D como por ejemplo la industria de los videojuegos, trata de replicarla y adaptarla en sus proyectos más modernos, con el fin de obtener mayor fidelidad visual.
El creciente interés ante el trazado de rayos ha provocado que compañías dedicadas al hardware gráfico dediquen parte de su desarrollo a la implementación del trazado de rayos en sus últimos modelos. Véase, por ejemplo, las últimas dos series de tarjetas gráficas de NVIDIA, las series RTX (del inglés Ray Tracing Texel eXtreme).

No obstante, la implementación de este sistema de renderizado peca de una gran demanda computacional, por lo que gran parte de los motores de renderizado orientados a la industria cinematográfica han sido adaptados para poder funcionar en aceleradores gráficos. Con la creciente capacidad computacional y las características fotorrealistas mencionadas anteriormente, los motores de renderizado de trazado de rayos han adquirido una especial importancia en el ámbito de la computación gráfica.

\section{Objetivos}
	
Este trabajo cubre brevemente las bases teóricas de un motor de renderizado fotorrealista con características no muy distantes de otros motores comerciales, incluyendo una implementación propia en CUDA desde cero. Dicha implementación ha sido desarrollada por mí, para este trabajo, y bautizada como Eleven Renderer. Es de código abierto y puede encontrarse en \url{https://github.com/101001000/tfg-pathtracer}.

Eleven Renderer está basado en el algoritmo de \emph{Path Tracing}, un tipo de trazado de rayos específico caracterizado por su capacidad de simular luz indirecta. Además, este trabajo hace hincapié en el análisis de dicha implementación en GPUs modernas, poniendo a prueba distintos parámetros y optimizaciones.
	
Eleven Renderer cuenta con propiedades no muy alejadas del estado del arte: es capaz de renderizar escenas del orden de millones de triángulos en tiempos razonables; usa un modelo de sombreado realista desarrollado por Disney \cite{burley2012physically}; permite el uso de mapas de textura y además funciona en GPU.

Un aspecto importante en cuanto a esta implementación de Eleven Renderer es que se intenta limitar el número de librerías usadas, con el fin de indagar a fondo en la arquitectura de un motor de renderizado de \emph{Path Tracing} de manera íntegra. Así pues, se desmitifica el trabajo que normalmente se delega a las librerías gráficas, y se expone de manera clara el funcionamiento de cada pieza de un motor de renderizado de Path Tracing en GPU.

Este documento cuenta con seis capítulos:

\begin{itemize}
	\item \autoref{chap:1}: Introducción. Se incluye una breve introducción de cada capítulo además de ofrecer un contexto al trabajo.
	\item \autoref{chap:2}: Implementación básica de Path Tracing. Se explican los fundamentos de este algoritmo y su implementación paralelizada en Eleven Renderer. 
	\item \autoref{chap:3}: Mejoras visuales. El algoritmo de \emph{Path Tracing} es un algoritmo muy abierto y existen muchos detalles que pueden ser añadidos con el fin de crear resultados con más detalles visuales. Este capítulo cubre las mejoras que se han considerado necesarias para garantizar una fidelidad visual mínima.
	\item \autoref{chap:4}: Optimizaciones estructurales. Muchas mejoras visuales necesitan de optimizaciones adicionales para tener tiempos de ejecución razonables. En este capítulo se explican las optimizaciones a nivel de algoritmo realizadas.
	\item \autoref{chap:evaluation}: Evaluación. Varias características implementadas son evaluadas, además de realizar un perfil general del algoritmo con NVIDIA NSight para identificar las posibles optimizaciones futuras.
	\item \autoref{chap:6}: Conclusiones. 
\end{itemize}

Cabe destacar que toda figura es original y que todas las muestras, comparaciones visuales y renders 3D han sido realizadas con Eleven Renderer, salvo las excepciones que están debidamente señaladas. La mayor parte del código, excepto el indicado o bien en la memoria, o bien en el código fuente, es una interpretación personal del material académico estudiado al respecto.

\section{Plan de trabajo}
	
\subsection{Trabajo previo}

\paragraph{Código abierto}\mbox{} \\

Actualmente existen diversas implementaciones de motores de renderizado por \emph{Path Tracing} de código abierto. La mayoría de ellas son implementaciones directas de los libros Ray Tracing in one Weekend \cite{shirley2016ray} o del libro Physically based rendering: From theory to implementation \cite{pharr2016physically} siendo el primero una rápida implementación funcional, mientras que el segundo contiene casi todos los fundamentos teóricos acompañados de una implementación muy completa.

Ambos libros han servido excelentemente como documentación, aún así, ambos están orientados a renderizado por CPU, toda la arquitectura que acompaña sobre todo el segundo libro, busca el mayor nivel de abstracción posible. Esto es un problema a la hora de usar CUDA, ya que no permite el uso de funciones virtuales y por tanto cuenta con una herencia de clases limitada.

La mayoría de estas implementaciones de código abierto son pruebas de concepto y la mayoría están limitadas en cuanto a características, pero hay una implementación concreta que destaca: Cycles.

Cycles es sin duda una de las implementaciones de código abierto más relevantes de este algoritmo. Es un motor de renderizado desarrollado por Blender, flexible y con implementación en distintas APIs, entre ellas CUDA, para poder hacer uso de múltiples tipos de aceleradores. Además ofrece una amplia gama de características como motor gráfico, a la par de las características vistas en el estado del arte, que le permiten hacerse hueco entre el resto de motores de render de producción comerciales.

\paragraph{Aplicaciones comerciales}\mbox{} \\

Hasta ahora se ha hablado de las implementaciones de código abierto, pero es imposible ignorar las aplicaciones comerciales. Debido a que el renderizado fotorrealista es una herramienta muy cotizada en la industria audiovisual, grandes empresas han desarrollado o adquirido motores de \emph{Path Tracing} propietarios. Unos cuantos ejemplos de motores de renderizado comerciales acelerados por GPU se muestran a continuación:

\begin{itemize}

\item Autodesk: Arnold Render
\item Blender Foundation: Cycles
\item Marmoset: Marmoset Toolbag
\item Otoy: Octane Render
\item Maxon: Redshift
\item Pixar: Renderman
\item Chaos Group: V-Ray

\end{itemize}

La gran mayoría de los motores mencionados funcionan exclusivamente con aceleradores de NVIDIA debido a que están implementados con CUDA. De la misma manera, Eleven Renderer hará uso de esta misma API, con el fin de imitar y seguir el desarrollo de la industria.

\subsection{Desarrollo del trabajo}
	
El objetivo del desarrollo de este motor de render ha sido implementar el mayor número de características de un motor gráfico de producción y analizarlas una a una. Es por ello que la planificación ha carecido de una estructura formal, y ha sido remodelada constantemente a partir de los logros y el progreso obtenido hasta la fecha.

A continuación se muestra una línea del tiempo con los hitos logrados:	

\begin{table}[H]
	\renewcommand\arraystretch{1.4}
	\captionsetup{singlelinecheck=false, font=blue, labelfont=sc, labelsep=quad}
	\caption{Timeline}\vskip -1.5ex
	\begin{tabular}{@{\,}r <{\hskip 2pt} !{\foo} >{\raggedright\arraybackslash}p{5cm}}
	\toprule
	\addlinespace[1.5ex]
	
	Octubre 2020 & Finalización de lectura del curso TU WIEN Rendering\footnotemark \\
	Noviembre 2020 & Inicialización de proyecto, prototipo inicial de trazado de rayos en CUDA y visualización con SFML, implementación de texturas\\
	Diciembre 2020 & Mapeado UV, Disney BRDF, carga de modelos .obj\\
	Enero 2021 & BVH construcción y recorrido\\
	Abril 2021 & SAH y comienzo de escritura de la memoria, visualizador BRDF\\
	Febrero 2021 & HDRI y NEE\\
	Marzo 2021 & Muestreo por importancia de HDRI\\
	Mayo 2021 & Funciones de benchmarking\\
	Agosto 2021 & Implementación de mapas de normales, BOKEH\\
	Septiembre 2021 & Escenas en formato JSON\\
	
\end{tabular}
\end{table}

Se está realizando también, de forma paralela, un port a Intel oneAPI, aunque este trabajo no cubre dicho apartado debido al progreso en desarrollo inacabado del mencionado port.

\footnotetext{TU Wien Rendering Lectures: \url{https://www.youtube.com/watch?v=pjc1QAI6zS0&list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi}}

\chapter*{Introduction}
\markboth{INTRODUCTION}{INTRODUCTION}

3D rendering is a technique which represents three dimensional geometry data in a two dimensional screen. There are different 3D rendering techniques, Ray Tracing being the most used in the film industry, thanks to the exceptional photorealism which other techniques lack. It's so valued this technique that nowadays, 3D visualization related industries lique video game industry, try to implement and adapt it to their most modern projects. Growing interest in Ray Tracing has made graphics hardware related companies spend part of their development resources into the implementations of Ray Tracing in their latest models. For example, the last two GPU series from NVIDIA, RTX series (Ray Tracing Texel eXtreme)

Nevertheless, the implementation of this rendering scheme, requires many computational resources, for that reason, a big part of the 3D rendering engines are being adapted to work with hardware graphics accelerators. With the growing computational capacity and the photorealistic characteristics mentioned before, Ray Tracing rendering engines did acquire a special importance in graphics computing.

\section{Objectives}
	
This work covers briefly the theoretical bases of a photorealistic 3d engine, with characteristics not far away from other commercial engines. This implementation includes their own CUDA implementation from scratch. This implementation has been developed by myself, for this work, and has been called Eleven Renderer. It is Open Source and can be found in \url{https://github.com/101001000/tfg-pathtracer}.

Eleven Renderer has their foundations on the Path Tracing algorithm, a kind of Ray Tracing, able to simulate global illumination. This work also emphasizes the analysis of this implementation in modern GPUS, testing different parametters and optimizations.

Eleven Renderer has properties not far away from the state of the art: it can render scenes in the order of million triangles in reasonable times; it uses a realistic shading model developed by Disney \cite{burley2012physically}; it allows the use of texture maps and it also works on the GPU.

An important aspect for this implementation is that it has been tried to limit the number of libraries used to get a deeper understanding of a Path Tracing engine architecture. The work which usually is done by the graphics libraries is demystified, and the internal workings of the engine are explained.


This document has six chapters:


\begin{itemize}
	\item \autoref{chap:1}: Introduction. A brief context is given about how the work has been done and what to expect from it.
	\item \autoref{chap:2}: Path Tracing basic implementation. Its explained the pipeline and how its parallelized the basics of the Path Tracing algorithnm. 
	\item \autoref{chap:3}: Visual improvements. Path Tracing's algorithm is really open and allows a big number of changes to make it more appealing.
	\item \autoref{chap:4}: Optimizations. Many of the visual improvements require some optimizactions to have reasonable rendering times.
	\item \autoref{chap:evaluation}: Evaluation. A couple changes are evaluated and benchmarked, also a its used NVIDIA NSight to make a profile the app.
	\item \autoref{chap:6}: Conclusions.
\end{itemize}

Every figure it's original, and every 3D render except where indicated, has been done with Eleven Renderer. Most of the code, except indicated in the source file or this document, is a personal interpretation and implementation of the academic material.


\section{Work plan}
	
\subsection{Previous work}

\paragraph{Open Source}\mbox{} \\

Nowadays, many open source implementations of Path Tracing exist. Most of them are direct implementations of the books Ray Tracing in one Weekend \cite{shirley2016ray} or Physically based rendering: From theory to implementation \cite{pharr2016physically}. The first is a quick functional implementation and the second one contains almost every foundation of the Path Tracing, accompanied with a very complete implementation.

Both books have excellenetly worked as documentation, that being said, both are aimed at CPU rendering, all the architecture which brings the second book, it's focused on abstracting every component. This is a problem when using CUDA, as it doesn't allow the usage of virtual functions, so it has a limited classes inheritance 

Most of these open source implementations are proof of concepts, and most of them are feature limited. There's one implementation which shines: Blender Cycles.

Cycles is without doubt, one of the most relevant open source implementations of this algorithm. Is a renderer developed by Blender, flexible and with implementations in different APIs, like CUDA, so many different accelerators can be used. It also offers a broad range of graphical features, most of them in the state of the art. These features allow Cycles to find his place among the rest of the commercial production rendering engines.

\paragraph{Commercial applications}\mbox{} \\

At the moment, only Open Source implementations have been mentioned, but it's impossible to ignore commercial applications. Because photorealistic rendering is a very valuable tool in the audiovisual industry, big businesses have developed or acquired some Path Tracing proprietary 3D renderers. A couple examples are:

\begin{itemize}

	\item Autodesk: Arnold Render
	\item Blender Foundation: Cycles
	\item Marmoset: Marmoset Toolbag
	\item Otoy: Octane Render
	\item Maxon: Redshift
	\item Pixar: Renderman
	\item Chaos Group: V-Ray

\end{itemize}

Most of the mentioned engines work exclusively with NVIDIA accelerators because they are implemented in CUDA. The same way, Eleven Renderer uses this same API trying to mimic the industry.

\subsection{Work development}
	
The objective of the development of this rendering engine has been to implement the biggest number of features for a production rendering engine and to analyze it. For that reason, the planification has lacked a formal structure, and has been defined from the milestones and achievements to the date. A timeline with the milestones is shown:
	
\begin{table}[H]
	\renewcommand\arraystretch{1.4}
	\captionsetup{singlelinecheck=false, font=blue, labelfont=sc, labelsep=quad}
	\caption{Timeline}\vskip -1.5ex
	\begin{tabular}{@{\,}r <{\hskip 2pt} !{\foo} >{\raggedright\arraybackslash}p{5cm}}
	\toprule
	\addlinespace[1.5ex]
	
	October 2020 & TU WIEN Rendering lectures finished\footnotemark \\
	November 2020 & Project setup, initial Path Tracing prototype in CUDA and SFML visualization, texture maps\\
	December 2020 & UV Mapping, Disney BRDF, .obj 3D model loading\\
	January 2021 & BVH build and traversal\\
	April 2021 & SAH and start the documentation, BRDF visualizer\\
	February 2021 & HDRI and NEE\\
	March 2021 & HDRI importance sampling\\
	May 2021 & Benchmarking methods\\
	August 2021 & Normal map implementations, BOKEH\\
	September 2021 & JSON Scenes\\
	
\end{tabular}
\end{table}

It's being developed at the same time, a Intel oneAPI port, but this work doesn't cover it as the progress is not finished.

\footnotetext{TU Wien Rendering Lectures: \url{https://www.youtube.com/watch?v=pjc1QAI6zS0&list=PLujxSBD-JXgnGmsn7gEyN28P1DnRZG7qi}}

